#!/Users/arsemag/CS4700_Net_Projects/transport-starter-code-main/.venv/bin/python3
import argparse
import socket
import json
import select
import sys
import time  # Needed for RTT estimation

DATA_SIZE = 1375


class Sender:
    def __init__(self, host, port):
        self.host = host
        self.port = int(port)
        # self.log("Sender starting up using port %s" % self.port)
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('0.0.0.0', 0))

        # RTT estimation initialization
        self.rtt_estimate = 0.5  # initial RTT estimate in seconds
        self.rtt_alpha = 0.125  # smoothing factor for RTT estimation
        self.timeout = 2 * self.rtt_estimate  # timeout is twice the RTT
        self.socket.settimeout(self.timeout)
        self.send_times = {}  # Maps packet sequence numbers to the send time

        self.window_size = 4
        self.expected_window = set()
        self.current_window_base = 0  # Base sequence number for the current window
        self.sent_out_packets = set()  # Packets sent but not yet acked
        self.acknowledged_packet = set()  # All packets that have been acknowledged
        self.packets_sent_so_far = {}  # Maps seq -> message payload

        self.missing = set()  # Packets in the current window that need to be re-sent
        self.received_acks_of_current_window = set()  # ACKs received in the current window

        self.waiting = False  # Indicates whether we are waiting for ACKs

        self.remote_host = None
        self.remote_port = None

        # Indicates that no more data is available from input.
        self.finished = False
        # When finished, final_seq is the sequence number for the next packet that would have been sent.
        self.final_seq = None

    # def log(self, message):
    #     sys.stderr.write(message + "\n")
    #     sys.stderr.flush()

    def send(self, message):
        # self.log("Sending message '%s'" % json.dumps(message))
        if message.get("type") == "msg":
            seq = message.get("seq")
            # Record the send time for RTT estimation.
            self.send_times[seq] = time.time()
        self.socket.sendto(json.dumps(message).encode("utf-8"), (self.host, self.port))

    def recv(self, sock):
        data, addr = sock.recvfrom(65535)
        if self.remote_host is None:
            self.remote_host = addr[0]
            self.remote_port = addr[1]
        if addr != (self.remote_host, self.remote_port):
            # self.log("Error: Received response from unexpected remote; ignoring")
            return None
        else:
            # self.log("Received message %s" % data)
            return json.loads(data.decode("utf-8"))

    def handle_socket_input(self):
        """Process incoming ACKs (and FINs) for the current window."""
        ack_count = 0
        # Determine how many ACKs to expect.
        if self.finished:
            expected_count = self.final_seq - self.current_window_base
        else:
            expected_count = self.window_size

        # self.log(f"DEBUG: BEFORE WHILE LOOP\nack_count={ack_count}\nexpected_count={expected_count}")
        while ack_count < expected_count:
            try:
                data = self.recv(self.socket)
                if data is None:
                    continue
                if data["type"] == 'ack':
                    seq = data["seq"]
                    # If we have a recorded send time for this packet, update our RTT estimate.
                    if seq in self.send_times:
                        sample_rtt = time.time() - self.send_times[seq]
                        # Update the estimated RTT using an exponential weighted moving average.
                        self.rtt_estimate = (1 - self.rtt_alpha) * self.rtt_estimate + self.rtt_alpha * sample_rtt
                        self.timeout = 2 * self.rtt_estimate
                        self.socket.settimeout(self.timeout)
                    if seq not in self.acknowledged_packet:
                        print(f'DEBUG: SEQ # {seq} IS NOT IN ACKED PACKETS ADDING NOW...', file=sys.stderr)
                        self.acknowledged_packet.add(seq)
                        print(f'DEBUG: ACKED PACKETS AFTER ADDING\n{self.acknowledged_packet}', file=sys.stderr)
                        self.sent_out_packets.discard(seq)
                        self.received_acks_of_current_window.add(seq)
                    else:
                        print(f'DEBUG: SEQ HAS ALREADY BEEN ACKED\nINCREASING EXPECTED COUNT...\nINCREASING ACK COUNT...\nMOVING ON...', file=sys.stderr)
                        expected_count += 1
                        ack_count += 1
                        continue
                    # Count duplicate ACKs as well.
                    ack_count += 1
            except socket.timeout:
                self.log("Socket timeout while waiting for ACKs.")
                break
        self.process_window_acks()
        self.expected_window.clear()

    def handle_stdin_input(self, seq):
        """
        Reads data from standard input and sends packets for the current window.
        If there are missing packets from a previous window, re-send those first.
        """
        sent_seq = seq
        for _ in range(self.window_size):
            if self.missing:
                # Retransmit missing packet(s)
                missing_seq = self.missing.pop()
                msg = self.packets_sent_so_far[missing_seq]
                self.send(msg)
                self.expected_window.add(missing_seq)
            else:
                data = sys.stdin.read(DATA_SIZE)
                if not data:
                    # No more data to read. Mark as finished and record final sequence.
                    self.finished = True
                    self.final_seq = sent_seq
                    break
                msg = {"type": "msg", "data": data, "seq": sent_seq}
                self.sent_out_packets.add(sent_seq)
                self.packets_sent_so_far[sent_seq] = msg
                self.send(msg)
                self.expected_window.add(sent_seq)
                sent_seq += 1
        return sent_seq

    def process_window_acks(self):
        """
        Checks the current window for missing ACKs.
        If some packets in the window were not acknowledged (or a timeout occurred),
        mark them for retransmission and decrease the window size.
        Otherwise, slide the window and increase the window size by 1.
        """
        if self.finished:
            expected_window = set(range(self.current_window_base, self.final_seq))
        # print(
        #     f"DEBUG: BEFORE FINDING MISSING\nexpected_window: {self.expected_window}\nreceived acks of current window: {self.received_acks_of_current_window}",
        #     file=sys.stderr)
        missing_in_window = self.expected_window - self.received_acks_of_current_window
        # print(
        #     f"DEBUG: AFTER FINDING MISSING\nmissing in window {missing_in_window}\nexpected_window: {self.expected_window}\nreceived acks of current window: {self.received_acks_of_current_window}",
        #     file=sys.stderr)

        if missing_in_window:
            # self.log(f"Missing packets in current window: {missing_in_window}")
            self.missing.update(missing_in_window)
            self.current_window_base = min(missing_in_window)
            # Decrease window size (with a minimum of 1)
            self.window_size = max(1, self.window_size // 2)
        else:
            if self.finished:
                self.current_window_base = self.final_seq
            else:
                self.current_window_base += self.window_size
            # Increase window size by 1 when all ACKs are received
            self.window_size *= 2

        # Clear ACKs for the next window cycle.
        self.received_acks_of_current_window.clear()

    def run(self):
        seq = 0
        while True:
            # If waiting for ACKs, only check the socket.
            sources = [self.socket] if self.waiting else [self.socket, sys.stdin]
            ready, _, _ = select.select(sources, [], [], self.timeout)

            if self.waiting and not ready:
                # self.log("DEBUG: ENTERING NOT WAITING AND NOT READY")
                self.handle_socket_input()
                self.waiting = False

            for source in ready:
                if source == self.socket:
                    self.handle_socket_input()
                    self.waiting = False
                elif source == sys.stdin:
                    seq = self.handle_stdin_input(seq)
                    self.waiting = True

            # Exit when finished reading input and no outstanding packets remain.
            if self.finished and not self.sent_out_packets:
                # self.log("All done!")
                sys.exit(0)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Send data over UDP with reliability.')
    parser.add_argument('host', type=str, help="Remote host to connect to")
    parser.add_argument('port', type=int, help="UDP port number to connect to")
    args = parser.parse_args()
    sender = Sender(args.host, args.port)
    sender.run()



