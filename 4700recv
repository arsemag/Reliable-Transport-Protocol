#!/home/ctf-machine/PycharmProjects/transport-starter-code-main/.venv/bin/python3

import argparse, socket, time, json, select, struct, sys, math, copy

class Receiver:
    def __init__(self):
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('0.0.0.0', 0))
        self.port = self.socket.getsockname()[1]
        self.log("Bound to port %d" % self.port)
        self.window_size = 2
        self.received_sequences = set()
        self.socket.settimeout(2.0)

        #Try to get test 1 - 3 to all pass
        self.received_packet_of_current_window = set()
        self.what_we_want = set()
        self.where_are_we =  0
        self.back_burner = {}
        self.seq_number_counter = 0
        self.increase_window_size_counter = 0
        self.stop_what_we_want_at_this_number = -1

        self.remote_host = None
        self.remote_port = None

    def send(self, message):
        self.log("Sent message %s" % json.dumps(message))
        self.socket.sendto(json.dumps(message).encode("utf-8"), (self.remote_host, self.remote_port))

    def recv(self, socket):
        data, addr = socket.recvfrom(65535)
        # print(f"DEBUG: received {data}", file=sys.stderr)

        # Grab the remote host/port if we don't already have it
        if self.remote_host is None:
            self.remote_host = addr[0]
            self.remote_port = addr[1]

        # Make sure we're talking to the same remote host
        if addr != (self.remote_host, self.remote_port):
            self.log("Error:  Received response from unexpected remote; ignoring")
            return None
        else:
            self.log("Received message %s" % data.decode("utf-8"))
            return json.loads(data.decode("utf-8"))

    def log(self, message):
        sys.stderr.write(message + "\n")
        sys.stderr.flush()

    def run(self):
        """
        Main loop to run the receiver.
        Continuously collects incoming data, checks for missing packets,
        handles the received window, and advances the window.
        """
        while True:
            self.collect_incoming_data()
            # self.check_missing_packets()
            self.handle_received_window()
            self.advance_window()

    def collect_incoming_data(self):
        """
        Collects incoming data packets.

        This method receives data packets up to the current window size.
        If a packet with a new sequence number is received, it is handled
        and acknowledged. If a duplicate packet is received, the window
        size is increased to account for it.
        """
        # print(f"debug: entered collect_incoming_data")
        i = 0
        size = self.window_size
        while i < size:
            try:
                msg = self.recv(self.socket)
                # print(f"DEBUG: msg = {msg}", file=sys.stderr)
                if msg['type'] == 'msg' and msg["seq"] not in self.received_sequences:
                    # print(f"DEBUG: are we in here yet", file=sys.stderr)
                    self.received_sequences.add(msg["seq"])
                    self.received_packet_of_current_window.add(msg["seq"])
                    self.handle_new_packet(msg)

                elif msg['type'] == 'fin':
                    self.stop_what_we_want_at_this_number = msg["seq"]
                    self.send({"type": "fin", "seq": msg["seq"]})

                else:
                    size += 1
            except socket.timeout:
                self.log("Timeout occurred, sending NACK")
                # print(f"debug: waw={self.where_are_we}, waw+win_size={self.where_are_we + self.window_size}", file=sys.stderr)
                self.check_missing_packets()
                # Send NACK for the next expected sequence or missing window
                # for seq in range(self.where_are_we, self.where_are_we + self.window_size):
                #     if seq not in self.received_sequences:
                #         self.send({"type": "nack", "seq": seq})
                break
            # if msg and msg["seq"] not in self.received_sequences:
            #     self.handle_new_packet(msg)
            # else:
            #     size += 1
            i += 1
        self.window_size += 1

    def handle_new_packet(self, msg):
        """
        Handles a new packet by adding its sequence number to the received sequences,
        acknowledging the packet, and printing the packet data in order.

        Args:
            msg (dict): The message containing the packet data and sequence number.
        """
        self.received_sequences.add(msg["seq"])
        # self.received_packet_of_current_window.add(msg["seq"])
        self.send({"type": "ack", "seq": msg["seq"]})

        def jitter():
            """
            Prints the packet data in order based on the sequence number.
            If the current sequence number matches the expected sequence number,
            it prints the data and increments the sequence number counter.
            If the expected sequence number is in the back burner, it prints the
            data from the back burner and increments the sequence number counter.
            Otherwise, it stores the data in the back burner.
            """
            if self.seq_number_counter == msg["seq"]:
                print(msg["data"], end='', flush=True)
                self.seq_number_counter += 1
                jitter()
            elif self.seq_number_counter in self.back_burner:
                print(self.back_burner[self.seq_number_counter], end='', flush=True)
                self.seq_number_counter += 1
                jitter()
            else:
                self.back_burner[msg["seq"]] = msg["data"]

        jitter()

    def check_missing_packets(self):
        """
        Check for missing packets in the current window and send NACKs for them.
        If all packets are received, increase the window size.
        """
        print(f"stop what we want a this number = {self.stop_what_we_want_at_this_number}", file=sys.stderr)
        if self.stop_what_we_want_at_this_number == -1:
            for i in range(self.where_are_we, self.where_are_we + self.window_size):
                self.what_we_want.add(i)
        else:
            for i in range(self.where_are_we, self.stop_what_we_want_at_this_number):
                self.what_we_want.add(i)


        if self.what_we_want != self.received_packet_of_current_window:
            missing = self.what_we_want - self.received_packet_of_current_window
            for seq in missing:
                self.send({"type": "nack", "seq": seq})
        else:
            self.window_size += 1

    def handle_received_window(self):
        self.what_we_want.clear()
        self.received_packet_of_current_window.clear()

    def advance_window(self):
        self.where_are_we += self.window_size - 1


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='receive data')
    args = parser.parse_args()
    sender = Receiver()
    sender.run()