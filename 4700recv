#!/home/ctf-machine/PycharmProjects/transport-starter-code-main/.venv/bin/python3

import argparse, socket, time, json, select, struct, sys, math, copy


class Receiver:
    def __init__(self):
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('0.0.0.0', 0))
        self.port = self.socket.getsockname()[1]
        self.log("Bound to port %d" % self.port)
        self.window_size = 2
        self.received_sequences = set()
        self.socket.settimeout(4.0)

        # Try to get test 1 - 3 to all pass
        self.received_packet_of_current_window = set()
        self.what_we_want = set()
        self.where_are_we = 0
        self.back_burner = {}
        self.seq_number_counter = 0
        self.increase_window_size_counter = 0  # TODO we don't use this
        self.stop_what_we_want_at_this_number = -1

        self.remote_host = None
        self.remote_port = None

    def send(self, message):
        self.log("Sent message %s" % json.dumps(message))
        self.socket.sendto(json.dumps(message).encode("utf-8"), (self.remote_host, self.remote_port))

    def recv(self, socket):
        data, addr = socket.recvfrom(65535)
        # print(f"DEBUG: received {data}", file=sys.stderr)

        # Grab the remote host/port if we don't already have it
        if self.remote_host is None:
            self.remote_host = addr[0]
            self.remote_port = addr[1]

        # Make sure we're talking to the same remote host
        if addr != (self.remote_host, self.remote_port):
            self.log("Error:  Received response from unexpected remote; ignoring")
            return None
        else:
            self.log("Received message %s" % data.decode("utf-8"))
            return json.loads(data.decode("utf-8"))

    def log(self, message):
        sys.stderr.write(message + "\n")
        sys.stderr.flush()

    def run(self):
        """
        Main loop to run the receiver.
        Continuously collects incoming data, checks for missing packets,
        handles the received window, and advances the window.
        """
        while True:
            self.collect_incoming_data()
            print(f"DEBUG: ENTERING CHECK MISSING PACKETS...", file=sys.stderr)
            self.check_missing_packets()
            self.handle_received_window()
            self.advance_window()

    def collect_incoming_data(self):
        """
        Collects incoming data packets.

        This method receives data packets up to the current window size.
        If a packet with a new sequence number is received, it is handled
        and acknowledged. If a duplicate packet is received, the window
        size is increased to account for it.
        """
        # print(f"debug: entered collect_incoming_data")
        i = 0
        size = self.window_size
        while i < size:
            try:
                print(f"DEBUG: ENTERING TRY EXCEPT...", file=sys.stderr)
                msg = self.recv(self.socket)
                if msg['type'] == 'msg' and msg["seq"] not in self.received_sequences:
                    self.received_packet_of_current_window.add(msg["seq"])
                    self.handle_new_packet(msg)

                elif msg['type'] == 'fin':
                    self.stop_what_we_want_at_this_number = msg["seq"]
                    self.send({"type": "fin", "seq": msg["seq"]})

                elif msg['type'] == 'shit':
                    # print(f"DEBUG: BEFORE UPDATING WAW\n{self.where_are_we}", file=sys.stderr)
                    self.where_are_we -= 1
                    self.send({"type": "ack", "seq": msg["seq"]})
                    # print(f"DEBUG: AFTER UPDATING WAW\n{self.where_are_we}", file=sys.stderr)
                    # self.check_missing_packets()
                else:
                    size += 1
            except socket.timeout:
                # self.log("Timeout occurred, sending NACK")
                # print(f"debug: waw={self.where_are_we}, waw+win_size={self.where_are_we + self.window_size}", file=sys.stderr)
                self.check_missing_packets()
                break
            i += 1

    def handle_new_packet(self, msg):
        """
        Handles a new packet by adding its sequence number to the received sequences,
        acknowledging the packet, and printing the packet data in order.

        Args:
            msg (dict): The message containing the packet data and sequence number.
        """
        self.received_sequences.add(msg["seq"])
        # self.received_packet_of_current_window.add(msg["seq"])
        self.send({"type": "ack", "seq": msg["seq"]}) # TODO probably never send the ack again if we get type shit

        def jitter():
            """
            Prints the packet data in order based on the sequence number.
            If the current sequence number matches the expected sequence number,
            it prints the data and increments the sequence number counter.
            If the expected sequence number is in the back burner, it prints the
            data from the back burner and increments the sequence number counter.
            Otherwise, it stores the data in the back burner.
            """
            if self.seq_number_counter == msg["seq"]:
                print(msg["data"], end='', flush=True)
                self.seq_number_counter += 1
                jitter()
            elif self.seq_number_counter in self.back_burner:
                print(self.back_burner[self.seq_number_counter], end='', flush=True)
                self.seq_number_counter += 1
                jitter()
            else:
                self.back_burner[msg["seq"]] = msg["data"]

        jitter()

    def check_missing_packets(self):
        """
        Check for missing packets in the current window and send NACKs for them.
        If all packets are received, increase the window size.
        """
        print(
            f"DEBUG: BEFORE CREATION OF WWW\nwww={self.what_we_want}\nwaw={self.where_are_we}\nwin_size={self.window_size}\nrpocw={self.received_packet_of_current_window}\nswwwatn={self.stop_what_we_want_at_this_number}\n",
            file=sys.stderr)
        print(f"DEBUG: CREATING WWW...\n", file=sys.stderr)
        if self.stop_what_we_want_at_this_number == -1:
            for i in range(self.where_are_we, self.where_are_we + self.window_size):
                self.what_we_want.add(i)
        else:
            for i in range(self.where_are_we, self.stop_what_we_want_at_this_number):
                self.what_we_want.add(i)

        print(
            f"DEBUG: AFTER CREATION OF WWW\nwww={self.what_we_want}\nwaw={self.where_are_we}\nwin_size={self.window_size}\nrpocw={self.received_packet_of_current_window}\nswwwatn={self.stop_what_we_want_at_this_number}\n",
            file=sys.stderr)

        if self.what_we_want != self.received_packet_of_current_window:
            missing = self.what_we_want - self.received_packet_of_current_window
            for seq in missing:
                self.send({"type": "nack", "seq": seq})
        else:
            self.window_size += 1

        print(
            f"DEBUG: AFTER THE CHECKING WHAT'S MISSING\nwww={self.what_we_want}\nwaw={self.where_are_we}\nwin_size={self.window_size}\nrpocw={self.received_packet_of_current_window}\nswwwatn={self.stop_what_we_want_at_this_number}\n",
            file=sys.stderr)

    def handle_received_window(self):
        self.what_we_want.clear()
        self.received_packet_of_current_window.clear()

    def advance_window(self):
        self.where_are_we += self.window_size - 1


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='receive data')
    args = parser.parse_args()
    sender = Receiver()
    sender.run()
